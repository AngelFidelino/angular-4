HIGHLITHS    
    * Use this to create a new project with --no-strict mode from CLI 
        -> ng new ng4-complete-guide --no-strict
    * To include boostrap in the whole project we nee to add Bootstrap to the styles[] array in angular-cli.json or angular.json file, 
    but the path should be "node_modules/bootstrap/dist/css/bootstrap.min.css" NOT "../node_modules/bootstrap/dist/css/bootstrap.min.css"
    * Generate components automatically with "ng generate component [component_name]"
        Add "--skipTests true" for ignore test file creation -> ng g c [component_name] --skipTests true
        We can creat a sub-component, inside a folder which is inside app folder -> "ng g c recipes/recipe-list", "ng g c recipes/recipe-list/recipe-item"
    * [(ngModel)] is used also to set value to a property in .ts, not just in two-way-binding.
SECTION 2: The basic
* Angular looks for the selector, defined in modules.ts, anywhere inside project and replace with templates' code
* AppComponent is the root component for this project
* AppModule.ts -> Angular use modules to bundle pieces or components of the app into packages
                  It must have @NgModule decorator witch contains boostrap propeties which indicates to angular which components should it aware of at the time of whole applications start

Angular will not scan all of files, so in order to angular knows about new components we need to set it up on @NgModule/declarations of AppModule
    1. Import ./server/server.component without .ts extension 
    2. Add new component to declarations sections of @NgModule
    3. Add the html tag to app.component.html, the same tag that we wrote on @Component/selector from server.component.ts
        Ex: <app-server></app-server>

* Generate components automatically
    -> ng generate component <servers>
    -> ng g c <servers>
    This will create new component and update app.modules.ts

22. Working with Component Templates. We have 2 ways of define templates in Component
    1. templateUrl: './servers.component.html',
    2. template: '<app-server></app-server><app-server></app-server>'

23. Working with Component Styles. We have 2 ways of define styles in @Component
    1. styleUrls: ['./app.component.css']
    2. styles:[`
            h3{
            color: dodgerblue;
            }
        `]
    
    RULES: If we have lots of code we use external file (styleUrls) otherwise use inline styles

24. Fully Understanding the Component Selector
    Selectors must be unique, we cannot override in many places by accident.
    Selectors can be a html tag or an atribute
    1. selector: 'app-servers' -> <app-servers></app-servers>
    2. selector: '[app-servers]' -> <div app-servers></div>
    3. selector: '.app-servers' -> <div class="app-servers"></div>
    ASIDE NOTE: Selector by id IS NOT supported by angular
    Why? Angular looks for the selector, defined in modules.ts, anywhere inside project and replace with templates' code

    26. What is Databinding?
    Databinding = Communication 
    * Output Data. Between Typescript Code (business Logic) to Template (HTML), what users see
        We can use->
            1. String interpolation -> {{data}}
                String interpolation has to resolve a value to a string
                @Component({})
                export class ServerComponent{
                    serverId = 10;
                    getServerStatus(){
                        return this.serverStatus;
                    }
                }

            2. Property binding -> [property]="data"
                <button class="btn btn-primary" [disabled]="allowNewServer">Add server</button>
                <button class="btn btn-primary" [disabled]=!allowNewServer>Add server</button>
                <i [innerText]="allowNewServer"></i>
    * Event Binding. Between Template to Typescript code. For instance, when user clic on something we want to execute code on Typescript
        1. Event binding -> (event)="expression"
            * For events, you don't bind to onclick but only to click
            <button (click)="onServerCreation()">Add server</button>
        32. Passing and Using Data with Event Binding
            with $event we can pass and get data about the event 
            <input type="text" (input)="onUpdateServerName($event)"/>

    * Two-Way-Binding. Combination of both, Output Data and Event Binding. With this we are able to react events and output something at the same time
        1. [(ngModel)]="data". With this approach we dont need to use event bin & string interpolation in order to update a element at the moment when an event occurs.
            In the next example, using ngModel we can write in the input and at the same time the element <p> is getting updated with the new content.
            <input type="text" [(ngModel)]="serverName" />
            <p>{{serverName}}</p>
    
37. Understanding Directives
    Directives are Instructions in the DOM!
    Components are directives with a template, but there are directives with out templates.
    "Structural directives" (ngIf) add or remove elements and "attribute directives" dont, the only change the element they were placed on.
    Commonly, directives are added using attribute selector.
    In the example, we use ngIf directives, all directives need "*" before its name. NgIf indicates whether an element will be showed or not
    <p *ngIf="serverCreated">Server was created, server name is {{serverName}}</p>
    
    39. Enhancing ngIf with an Else Condition
    We can use <ng-template></ng-template> to mark places in the DOM.
    For instance, using Local reference (#noServer in this case):
    <p *ngIf="serverCreated; else noServer">Server was created, server name is {{serverName}}</p>
    <ng-template #noServer>
        <p>No server was created</p>
    </ng-template>

40. Styling Elements Dynamically with ngStyle
We this we are binding to a property of the directive.
<p [ngStyle]="{backgroundColor: getColor()}">{{'Server'}} with ID {{serverId}} is {{getServerStatus()}}</p>

41. Applying CSS Classes Dynamically with ngClass
    ngClass, with property binding, allows us to dinamically add or remove css Classes
    ngClass add css class if a condition is true, so ngClass take two part: [ngClass]="{<className>:<condition>}"
    <p [ngClass]="{online:serverStatus=='online'}"> </p>

42. Outputting Lists with ngFor
    In the next example, <app-server> will repeat as many as servers are
    Note how "let i = index" let you get the index of the iteration
    <app-server *ngFor="let server of servers; let i = index"></app-server>
    During *ngFor we can use string interpolation or property binding to get values from bucle, something like:
    <img src="{{recipe.imagePath}}" 
         [src]="recipe.imagePath"/>




SECTION 3: Course Project - The Basics
No every component shoul have a folder in the root level (/app), we can nest it by feature
    53. Creating a "Recipe" Model
    A model is Angular is a simple .ts file which contains property, this will be act like a blue print for objects we will create. It's a Class.




SECTION 5: Components & Databinding Deep Dive
    66. Property & Event Binding Overview
    we can bind custom propeties and custom events in our own components


        [(ngModel)] is used also to set value to a property in .ts, not just in two-way-binding.

    67. Binding to Custom Properties
        By default, elements from one component are only accessible by this component, not from outside
        Now, supose we have in app-component.html and we want to acess to "element" varible from server-component and set it a value
        <app-server-element *ngFor="let server of serverElements"
            [element]="server"></app-server-element>
        We need to add the decorator @Input() to "element" declaration, with this we are sucessfully exposing this property to the world. 
        Now any parent component, any component hosting our server element component, like app-component which is parent of server-component, can implementing "element" throught selectors like  [element]="server"
        
        Example:
            We hace two components: app and server-element, app-component.html have an element of app-server-element which is inside a for loop, for each item of serverElements (belongs to app) we want to implement the app-server-element.
            For this case we have:
            1. app-component.html -> <app-server-element *ngFor="let server of serverElements" [element]="server"></app-server-element>
            2. app-component.ts ->serverElements = [ {name:'Windows', type:'server', content:'Content'}}
            3. server-element-component.ts -> element: {name:string, type:string, content:string};
            4. server-element-component.html -> <strong *ngIf="element.type === 'server'" style="color: red">{{ element.content }}</strong>
            
            We expect, for each element of "serverElements" we print información of server in "<strong> tag". For that:
            Considering that in app-component.html we have binded already "element" property for each item of "serverElements", we only need to make public "element" property in server-element-component.ts, this "element" is used in server-element-component.html and assign from app-component.html with each element of "serverElements". The third line will be like:
            
                3. @Input() element: {name:string, type:string, content:string};
            With this, have binded already "element" property for each item of "serverElements" on app-component, that´s it.

            Aditional, we can set up an alias for public element "@Input('srvElement') element ...", so now from outside we have to refer to this element as [srvElement]="xxx"

    69. Binding to Custom Events
        What happend if we have a component and something changes in there and we want to inform our parent component which implements the other component
        
        EventEmitter is an object in ther Angular framework which allows us to emit our own events
        To emit event from one component to another with emit({data}) method from EventEmitter.
        Use @Output decorator for passing something out of the component
        Steps:
        1.- cockpit-component.html -> <button (click)="onAddServer()">Add Server</button>
        2.- cockpit-component.ts -> @Output() serverCreated = new EventEmitter<{serverName:string, serverContent:string}>();
        3.- cockpit-component.ts -> 
            onAddServer() {
                this.serverCreated.emit({
                serverName: this.newServerName,
                serverContent: this.newServerContent
                });
            }
        4.- app-component.html-> <app-cockpit (serverCreated)="onServerAdded($event)"></app-cockpit>
        5.- app-component.ts  -> onServerAdded(serverData:{serverName:string, serverContent:string}) {...}

        Steps description:
        1.- Setup the initial event in .html child component
        2.- Define the EventEmitter objet in .ts child component, using @Output and EventEmitter
        3.- Catch the initial event in .ts child component and emit it
        4.- In .html parent, catch the emitted and custom EventEmitter and indicate the parent method to process it
        5.- In .ts parent write de method to process the received data

        Aditional, we can set up an alias for public event "@Output('bpCreated') event ...", so now from outside we have to refer to this event as [bpCreated]="xxx"

    72. Understanding View Encapsulation
    Angular enforces a css behavior, when you define styles/css in a parent component this only apply for the component itself and not for anyother or its child component. This is not the behavior of the browser.
    
    Example [Style Encapsulation]:
        We have "p{ color: blue; }" in css file, at the end in the browser we'll see something like
        p[_ngcontent-qhf-c42] {
            color: blue;
        }
    Note: ¿how does Angular make this possible? -> each html element inside a component will have one common unique attibute, in the above example the property is "_ngcontent-qhf-c42"
    Note: we can override this behavior with encapsulation: ViewEncapsulation.xxx property, in the next example the style of this component will be apply to all elements of other components that match with the rules
    @Component({
        ....
        encapsulation: ViewEncapsulation.None
    })

    74. Using Local References in Templates
    Local references is a very nice feature to get access to some element in out template and then use it direclty in the template.
    A local reference can be placed on any html element, not only in Input element.
    The local reference will hold a reference to the whole html element, no just the value, where it is placed.
    Local references can be called on every part of the html template and only there, not from .ts. If we need it in .ts we need to pass as a method parameter from html to .ts.
    
    Steps
    1.- html -> <input type="text" class="form-control" #serverNameInput>
    2.- html -> <button (click)="onAddServer(serverNameInput)">Add Server</button>
    3.- ts -> onAddServer(input) {
            console.log('input.value: '+ input.value);
        }

    Steps description
    1. Define local reference
    2. get reference in same html
    3. get value from ts

 76. Getting Access to the Template & DOM with @ViewChild
        Another way to getting access to local references from typescript is using @ViewChild('[selector]') with a selector.
        Unlike passing local reference direclty from html, with @ViewChild the element received is a type of ElementRef (a reference to the element)

        RECOMENDATION: Not use @ViewChild to update html element from typescript

        Example:
        1. Html -> <input type="text" class="form-control" #serverContentInput>
        2. ts   -> @ViewChild('serverContentInput') serverContentInput: ElementRef;
        2. ts   -> onAddServer() {
                        console.log(this.serverContentInput.nativeElement.value)
                    }

    77. Projecting Content into Components with ng-content
        Another way to pass data arround :)
        By default, everthing you place between the opening and closing tag of your own component is lost by default.
        Supose, we hace server-element and app-component. In app-commponent we define a ngFor for each <app-server-element> but the data is lost.
        app-component.html ->
        <app-server-element *ngFor="let server of serverElements" [srvElement]="server">
            <strong *ngIf="server.type === 'server'" style="color: red">{{ server.content }}</strong>
        </app-server-element>
        To make this possible we can use a directive in html child component, in the place where you want to render the component.
        The <ng-content></ng-content> direclty mark the place for Angular where it should add any content it finds between the opening and closing tag.

        1. (child) server-element.html ->   <div class="panel-body">
                                                <ng-content></ng-content>
                                            </div>
        2. (parent) app-commponent.html ->  <app-server-element *ngFor="let server of serverElements" [srvElement]="server">
                                                <strong *ngIf="server.type === 'server'" style="color: red">{{ server.content }}</strong>
                                            </app-server-element>



    1. isr simplificiado de confisanza persona fisica
    2. iva retenciones
    3. 
    4. 

    78. Understanding the Component Lifecycle
        When Angular create a component it executes some phases, and it will give us a chance to hook into these phases and execute some code
        ngOnChanges() -> Called after a bound input property (@Input) changes
        ngOninit()    -> Called once the component is initialized. It will run after the constructor. The component has not been added to the DOM yet, but Angular has finised the basic initializacion
        ngDoCheck()   -> Called during every change detection run. This runs event on click event (when user clicks on some element). Warning!! Due to this method run very often we dont have to use it a lot.
        ngAfterContentInit -> Called after content (ng-content) has been projected into View
        ngAfterContentChecked
        ngAfterViewInit() -> Called after the component’s view (and child views) has been initialized. it is executed after elements have been rendered.
        ngAfterViewChecked
        ngOnDestroy()-> Called once the component is about to be destroyed

        Note: it´s a good practice indicate which method will be implemented, even it is not necesary.
        ngOnChanges its the only one which receive an argument of type changes: SimpleChanges
        export class ServerElementComponent implements OnInit, OnChanges {
            ngOnChanges(changes: SimpleChanges): void {}
            ngOnInit(): void {}
        }

    82. Getting Access to ng-content with @ContentChild
    @ContentChild to get access to content which is store in another component

    1. app-commponent.html    -> <p #paragraphContent>Some content</p>
    2. server-commponent.html -> @ContentChild('paragraphContent', {static: true}) paragraph: ElementRef;
    3. server-commponent.html -> ngAfterViewInit(){
                                    console.log(this.paragraph.nativeElement.textContent)
                                 } 

    @ContentChild vs @ViewChild.
        La diferencia principal es el contexto en el que realiza la búsqueda.
        @ViewChild -> realizará la busqueda entre los elementos que hay en la plantilla del mismo component
        @ContentChild -> entre los elementos del contenido proyectado. El "contenido proyectado" es aquel que definimos entre las etiquetas del componente
                        cuando incuimos este en otra parte de la aplicación

        Ejemplo de "contenido proyectado":
        1. (parent) app-commponent.html ->
            <app-server-element *ngFor="let server of serverElements"
            [srvElement]="server">
                <p #paragraphContent>Content text</p>
            </app-server-element>
        2. (child) server-commponent.ts -> @ContentChild('paragraphContent', {static: true}) paragraph: ElementRef;
        
        Descripción de pasos:
        1. Desde el component padre, el component hijo <app-server-element> tiene proyectado su contenido, es decir, dentro de las eqtiquetas tiene html
        2. De esta forma, desde el typescript de app-server-commponent.ts podemos acceder al elemento #paragraphContent con @ContentChild
    
    @ContentChildren and @ViewChildren    
        @ContentChild and @ViewChild get just the first coincidence, in order to get all coincidences we use @ContentChildren and @ViewChildren
        -> @ViewChildren('xx')
            listItems: QueryList<ListItemComponent>